import random
import pandas as pd
import networkx as nx
from main import page_rank_calculations, modularity_calculations, create_relationship_space, morphospace_values


def randomize_graphs(G, number_of_new_graphs):
    new_graphs = []
    for graph_number in range(number_of_new_graphs):
        tmp_graph = G.copy()
        nodes_number = tmp_graph.number_of_nodes()
        for i in range (nodes_number):
            # container for selected randomly, two existing, different edges
            selectedEdges = []
            while len(selectedEdges) < 2:
                firstPartEdge = random.randrange(0, nodes_number - 1)
                secondPartEdge = random.randrange(0, nodes_number - 1)
                #checking if edge exist and if is not in selectdEdges
                if tmp_graph.has_edge(firstPartEdge, secondPartEdge) and (firstPartEdge, secondPartEdge) not in selectedEdges and (secondPartEdge, firstPartEdge) not in selectedEdges:
                    selectedEdges.append((firstPartEdge, secondPartEdge))
            #check if new connection exist. If exist, skip and go to random new pair
            if tmp_graph.has_edge(selectedEdges[0][0], selectedEdges[1][1]) or  tmp_graph.has_edge(selectedEdges[1][0],selectedEdges[0][1]):
                selectedEdges.clear()
                continue
            edge_0_weight = tmp_graph.get_edge_data(*selectedEdges[0])['weight']
            edge_1_weight = tmp_graph.get_edge_data(*selectedEdges[1])['weight']
            # remove edge for swap start and end point in edge
            tmp_graph.remove_edge(*selectedEdges[0])
            tmp_graph.remove_edge(*selectedEdges[1])
            # add new changed edges
            tmp_graph.add_edge(selectedEdges[0][0],selectedEdges[1][1],  weight=edge_0_weight)
            tmp_graph.add_edge(selectedEdges[1][0],selectedEdges[0][1],  weight=edge_1_weight)
            selectedEdges.clear()
        new_graphs.append(tmp_graph)
    return new_graphs


# Thresholded
adj1_file = "saved_adj_matrices/adj1_min.csv"
adj2_file = "saved_adj_matrices/adj2_min.csv"

adj_1_pd = pd.read_csv(adj1_file)
adj_2_pd = pd.read_csv(adj2_file)

# need to drop index column that is generated by pandas
adj_1_pd.drop(adj_1_pd.columns[0], axis=1, inplace=True)
adj_2_pd.drop(adj_2_pd.columns[0], axis=1, inplace=True)

# convert pd to numpy
adj_1 = adj_1_pd.to_numpy()
adj_2 = adj_2_pd.to_numpy()

# generate nx graphs from adj matrices
G1 = nx.from_numpy_matrix(adj_1)
G2 = nx.from_numpy_matrix(adj_2)

g1_random_graphs = randomize_graphs(G1, 1)
g2_random_graphs = randomize_graphs(G2, 1)

g1_pagerank, g2_pagerank =  page_rank_calculations(g1_random_graphs[0], g2_random_graphs[0])
g1_modularity, g2_modularity =  modularity_calculations(g1_random_graphs[0], g2_random_graphs[0])

g1_relationship = create_relationship_space(g1_pagerank, g1_modularity)
g2_relationship =  create_relationship_space(g2_pagerank, g2_modularity)

sum_page_rank1, mod_degree1 =  morphospace_values(g1_pagerank, g1_modularity)
sum_page_rank2, mod_degree2 =  morphospace_values(g2_pagerank, g2_modularity)

print(sum_page_rank1)
print(mod_degree1)
print(sum_page_rank2)
print(mod_degree2)
