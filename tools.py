import random
import pandas as pd
import networkx as nx
from main import page_rank_calculations, modularity_calculations, create_relationship_space, morphospace_values
import matplotlib as plt
import numpy as np

def randomize_graphs(G, number_of_new_graphs):
    new_graphs = []
    for graph_number in range(number_of_new_graphs):
        tmp_graph = G.copy()
        nodes_number = tmp_graph.number_of_nodes()
        for i in range (nodes_number):
            # container for selected randomly, two existing, different edges
            selectedEdges = []
            while len(selectedEdges) < 2:
                firstPartEdge = random.randrange(0, nodes_number - 1)
                secondPartEdge = random.randrange(0, nodes_number - 1)
                #checking if edge exist and if is not in selectdEdges
                if tmp_graph.has_edge(firstPartEdge, secondPartEdge) and (firstPartEdge, secondPartEdge) not in selectedEdges and (secondPartEdge, firstPartEdge) not in selectedEdges:
                    selectedEdges.append((firstPartEdge, secondPartEdge))
            #check if new connection exist. If exist, skip and go to random new pair
            if tmp_graph.has_edge(selectedEdges[0][0], selectedEdges[1][1]) or  tmp_graph.has_edge(selectedEdges[1][0],selectedEdges[0][1]):
                selectedEdges.clear()
                continue
            edge_0_weight = tmp_graph.get_edge_data(*selectedEdges[0])['weight']
            edge_1_weight = tmp_graph.get_edge_data(*selectedEdges[1])['weight']
            # remove edge for swap start and end point in edge
            tmp_graph.remove_edge(*selectedEdges[0])
            tmp_graph.remove_edge(*selectedEdges[1])
            # add new changed edges
            tmp_graph.add_edge(selectedEdges[0][0],selectedEdges[1][1],  weight=edge_0_weight)
            tmp_graph.add_edge(selectedEdges[1][0],selectedEdges[0][1],  weight=edge_1_weight)
            selectedEdges.clear()
        new_graphs.append(tmp_graph)
    return new_graphs


# Thresholded
adj1_file = "saved_adj_matrices/adj1_min.csv"
adj2_file = "saved_adj_matrices/adj2_min.csv"

adj_1_pd = pd.read_csv(adj1_file)
adj_2_pd = pd.read_csv(adj2_file)

# need to drop index column that is generated by pandas
adj_1_pd.drop(adj_1_pd.columns[0], axis=1, inplace=True)
adj_2_pd.drop(adj_2_pd.columns[0], axis=1, inplace=True)

# convert pd to numpy
adj_1 = adj_1_pd.to_numpy()
adj_2 = adj_2_pd.to_numpy()

# generate nx graphs from adj matrices
G1 = nx.from_numpy_matrix(adj_1)
G2 = nx.from_numpy_matrix(adj_2)

number_of_random_graphs = 100
g1_random_graphs = randomize_graphs(G1, number_of_random_graphs)
g2_random_graphs = randomize_graphs(G2, number_of_random_graphs)

mod_degrees_x_g1 = []
mod_degrees_x_g2 = []
page_ranks_y_g1 = []
page_ranks_y_g2 = []

for g1, g2 in zip(g1_random_graphs, g2_random_graphs):
    g1_pagerank, g2_pagerank =  page_rank_calculations(g1, g2)
    g1_modularity, g2_modularity =  modularity_calculations(g1, g2)

    g1_relationship = create_relationship_space(g1_pagerank, g1_modularity)
    g2_relationship =  create_relationship_space(g2_pagerank, g2_modularity)

    sum_page_rank1, mod_degree1 =  morphospace_values(g1_pagerank, g1_modularity)
    sum_page_rank2, mod_degree2 =  morphospace_values(g2_pagerank, g2_modularity)

    mod_degrees_x_g1.append(mod_degree1)
    page_ranks_y_g1.append(sum_page_rank1)
    mod_degrees_x_g2.append(mod_degree2)
    page_ranks_y_g2.append(sum_page_rank2)

plt.scatter(np.concatenate((mod_degrees_x_g1, mod_degrees_x_g2)), np.concatenate((page_ranks_y_g1, page_ranks_y_g2)), c= [0] * number_of_random_graphs + [1] * number_of_random_graphs)